# -*- coding: utf-8 -*-
"""sor-my-interpretation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TBX6uX409mfV-4GUJDQ9Ozm13yISC204

Successive Over-Relaxation (SOR) Methods for Elliptical Equations
====
Partial Differential Equations for Science and Engineering, Varquez, Tokyo Institute of Technology

## Algorithm for (SOR)

There is a need to replace the equation from the lecture regarding the SOR procedure to as follows to solve the following elliptical equation:

\begin{align}
\frac{\partial^2 T}{\partial x^2}+\frac{\partial^2 T}{\partial y^2}=g\frac{\rho}{T}
\end{align}

with the following finite difference method (centered-in-space) assuming $\Delta x=\Delta y$.

\begin{align}
\frac{T_{i+1,j}-2T_{i,j}+T_{i-1,j}}{\Delta x^2}+\frac{T_{i,j+1}-2T_{i,j}+T_{i,j-1}}{\Delta y^2}&=g\frac{\rho}{T} \\
T_{i+1,j}+T_{i-1,j}+T_{i,j+1}+T_{i,j-1}-4T_{i,j}&=\Delta x^2g\frac{\rho}{T}
\end{align}

further rearranging the above equation,

\begin{align}
T_{i,j} = \frac{1}{4}(T_{i+1,j}+T_{i-1,j}+T_{i,j+1}+T_{i,j-1}+\Delta x^2g\frac{\rho}{T})
\end{align}

**SOR Procedure:**

1. Set $k$ number of iterations.
2. Calculate the residual $R^{k}$ for each iteration loop as follows:

\begin{align}
R^{k}_{i,j}&=\frac{1}{4}(T^k_{i+1,j}+T^{k+1}_{i-1,j}+T^k_{i,j+1}+T^{k+1}_{i,j-1}-\Delta x^2g\frac{\rho}{T})-T^k_{i,j}
\end{align}

3. Conduct the adjustments for $T_{i,j}$ for $k+1$-th iteration:

\begin{align}
T^{k+1}_{i,j} = T^{k}_{i,j}+\omega R^{k}_{i,j}
\end{align}
"""

from IPython.display import HTML
from base64 import b64encode

def play(filename):
    html = ''
    video = open(filename,'rb').read()
    src = 'data:video/mp4;base64,' + b64encode(video).decode()
    html += '<video width=1000 controls autoplay loop><source src="%s" type="video/mp4"></video>' % src 
    return HTML(html)

import numpy as np
import matplotlib.pyplot as plt

import time
import resource

g = 9.81
RhoT = 0.01 #Corresponds to Rho over T from the equation above.
dx = dy = 1.
len_x = 100.
len_y = 100.
grid_x = int(len_x/dx)
grid_y = int(len_y/dy)

x = np.linspace(0.,grid_x*dx,grid_x)
y = np.linspace(0.,grid_y*dy,grid_y)

T = np.zeros((grid_y,grid_x))
T[:,0] = 200.
T[:,-1] = 200.
T[0,:] = 300.
T[-1,:] = 300.
T[50,50] = 100
w = 1.50 #Corresponding to omega in the SOR algorithm.
nk = 500 #Corresponds to the number of iterations.
print(T)

time_start = time.perf_counter()  # Time computation /To choose the most optimum value for omega/
for k in range(0,nk):
    for j in range(1,grid_y-1):
        for i in range(1,grid_x-1):
            R = 0.25*(T[j,i+1]+T[j,i-1]+T[j+1,i]+T[j-1,i]-g*RhoT*dx**2.)
            T[j,i] = (1-w)*T[j,i]+w*R
time_elapsed = (time.perf_counter() - time_start)
memMb=resource.getrusage(resource.RUSAGE_SELF).ru_maxrss/1024.0/1024.0
print ("%5.1f secs %5.1f MByte" % (time_elapsed,memMb))

plt.contourf(x,y,T,cmap='rainbow',levels=np.linspace(np.min(T),np.max(T),30))
#levels - argument which sets the minimum and maximum color. 
#Minimum and Maximum of T are used for the lowest and largest value.
plt.title('Steady-State, k=500')
plt.xlabel('Horizontal')
plt.ylabel('Vertical')
plt.colorbar()
plt.savefig('steady-state')
plt.show()